# .gitlab-ci.yml

# =============================================
# CI/CD Pipeline for Employee Management System
# PERN Stack with Prisma ORM
# =============================================

stages:
  - validate      # Code quality, security scans
  - test          # Unit tests, integration tests
  - build         # Docker image building
  - deploy        # Staging and production deployment
  - post-cleanup  # Cleanup operations

# =============================================
# Global Variables & Configuration
# =============================================

variables:
  DOCKER_TLS_CERTDIR: ""
  NODE_VERSION: "20"
  POSTGRES_VERSION: "15"

  # Docker Images
  FRONTEND_IMAGE: "amineelalami/ems-platform-frontend"
  BACKEND_IMAGE: "amineelalami/ems-platform-backend"
  DB_IMAGE: "amineelalami/ems-platform-db"

  # Tags for Docker images
  COMMIT_TAG: "sha-${CI_COMMIT_SHORT_SHA}-${CI_PIPELINE_ID}"
  VERSION_TAG: "v${CI_PIPELINE_ID}"

# =============================================
# Cache Configuration
# =============================================

cache:
  key: "${CI_COMMIT_REF_SLUG}"
  paths:
    - client/node_modules/
    - backend/node_modules/
  policy: pull-push
  when: on_success

# =============================================
# Job Templates
# =============================================

.docker_build_template: &docker_build_template
  image: docker:24
  services:
    - docker:24-dind
  variables:
    DOCKER_TLS_CERTDIR: ""
  before_script:
    - docker info
    - |
      # Security check for Docker Hub credentials
      if [ -z "$DOCKERHUB_TOKEN" ]; then
        echo "‚ùå DOCKERHUB_TOKEN is not set"
        exit 1
      fi
    - echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin

.test_template: &test_template
  image: node:${NODE_VERSION}
  cache:
    key: "${CI_COMMIT_REF_SLUG}"
    paths:
      - node_modules/
    policy: pull

# =============================================
# VALIDATION STAGE
# =============================================

# Validate code quality and security
lint_frontend:
  stage: validate
  image: node:${NODE_VERSION}
  script:
    - cd client
    - npm ci
    - echo "üîç Running frontend linting..."
    - npm run lint
  artifacts:
    when: always
    reports:
      junit: client/reports/lint-report.xml
  rules:
    - if: '$CI_COMMIT_REF_NAME == "dev" || $CI_COMMIT_REF_NAME == "main"'
    - changes:
        - client/src/**/*
        - client/package.json

lint_backend:
  stage: validate
  image: node:${NODE_VERSION}
  script:
    - cd backend
    - npm ci
    - echo "üîç Running backend linting..."
    - npm run lint
  artifacts:
    when: always
    reports:
      junit: backend/reports/lint-report.xml
  rules:
    - if: '$CI_COMMIT_REF_NAME == "dev" || $CI_COMMIT_REF_NAME == "main"'
    - changes:
        - backend/src/**/*
        - backend/package.json

# Security scanning (example - you can add more tools)
security_scan:
  stage: validate
  image: docker:24
  services:
    - docker:24-dind
  script:
    - echo "üîí Running security checks..."
    - apk add --no-cache curl
    - |
      # Example: Check for known vulnerabilities in dependencies
      if [ -f "client/package.json" ]; then
        cd client && npm audit --audit-level moderate || true
      fi
    - |
      if [ -f "backend/package.json" ]; then
        cd backend && npm audit --audit-level moderate || true
      fi
  rules:
    - if: '$CI_COMMIT_REF_NAME == "dev" || $CI_COMMIT_REF_NAME == "main"'

# =============================================
# DEPENDENCY SETUP (Optimized caching)
# =============================================

setup_frontend_deps:
  stage: validate
  image: node:${NODE_VERSION}
  script:
    - cd client
    - npm ci
  cache:
    key: "${CI_COMMIT_REF_SLUG}-frontend-deps"
    paths:
      - client/node_modules/
    policy: push
  artifacts:
    paths:
      - client/node_modules/
    expire_in: 1 hour
  rules:
    - changes:
        - client/package-lock.json
        - client/package.json

setup_backend_deps:
  stage: validate
  image: node:${NODE_VERSION}
  script:
    - cd backend
    - npm ci
    - npx prisma generate
  cache:
    key: "${CI_COMMIT_REF_SLUG}-backend-deps"
    paths:
      - backend/node_modules/
    policy: push
  artifacts:
    paths:
      - backend/node_modules/
    expire_in: 1 hour
  rules:
    - changes:
        - backend/package-lock.json
        - backend/package.json
        - backend/prisma/schema.prisma

# =============================================
# TEST STAGE
# =============================================

# Frontend Unit Tests
test_frontend_unit:
  stage: test
  image: node:${NODE_VERSION}
  dependencies:
    - setup_frontend_deps
  script:
    - cd client
    - echo "üß™ Running frontend unit tests..."
    - npm test -- --coverage --watchAll=false
  artifacts:
    when: always
    reports:
      junit: client/junit.xml
    paths:
      - client/coverage/
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  rules:
    - if: '$CI_COMMIT_REF_NAME == "dev" || $CI_COMMIT_REF_NAME == "main"'

# Backend Unit Tests
test_backend_unit:
  stage: test
  image: node:${NODE_VERSION}
  dependencies:
    - setup_backend_deps
  script:
    - cd backend
    - echo "üß™ Running backend unit tests..."
    - npm test -- --coverage --watchAll=false
  artifacts:
    when: always
    reports:
      junit: backend/junit.xml
    paths:
      - backend/coverage/
  rules:
    - if: '$CI_COMMIT_REF_NAME == "dev" || $CI_COMMIT_REF_NAME == "main"'

# Database Migration Tests
test_database_migrations:
  stage: test
  image: node:${NODE_VERSION}
  services:
    - postgres:${POSTGRES_VERSION}
  variables:
    POSTGRES_DB: test_employeedb
    POSTGRES_USER: tester
    POSTGRES_PASSWORD: test_password
    DATABASE_URL: "postgresql://tester:test_password@postgres:5432/test_employeedb"
  script:
    - cd backend
    - npm ci
    - npx prisma generate
    - echo "üóÑÔ∏è Testing database migrations..."
    - npx prisma migrate reset --force
    - npx prisma migrate dev --name ci-test
    - echo "‚úÖ Database migrations completed successfully"
  rules:
    - if: '$CI_COMMIT_REF_NAME == "dev" || $CI_COMMIT_REF_NAME == "main"'
    - changes:
        - backend/prisma/schema.prisma
        - backend/prisma/migrations/**/*

# Backend Integration Tests
test_backend_integration:
  stage: test
  image: node:${NODE_VERSION}
  services:
    - postgres:${POSTGRES_VERSION}
  variables:
    POSTGRES_DB: test_employeedb
    POSTGRES_USER: tester
    POSTGRES_PASSWORD: test_password
    DATABASE_URL: "postgresql://tester:test_password@postgres:5432/test_employeedb"
  script:
    - cd backend
    - npm ci
    - npx prisma generate
    - npx prisma migrate reset --force
    - echo "üîó Running backend integration tests..."
    - npm run test:integration || echo "‚ö†Ô∏è Integration tests failed but continuing pipeline"
  rules:
    - if: '$CI_COMMIT_REF_NAME == "dev" || $CI_COMMIT_REF_NAME == "main"'

# Database Image Test
test_db_image:
  image: docker:24
  stage: test
  services:
    - docker:24-dind
  variables:
    DOCKER_TLS_CERTDIR: ""
  before_script:
    - apk add --no-cache postgresql-client git
    - docker info
    - git fetch origin dump
    - git show origin/dump:db/employeedb_dump_pg15.sql > db/employeedb_dump_pg15.sql
  script:
    - echo "üóÑÔ∏è Testing database image build..."
    - test -f "db/employeedb_dump_pg15.sql" && echo "‚úÖ SQL file exists" || exit 1
    - docker build -t $DB_IMAGE:test ./db
    - echo "‚úÖ Database image built successfully"
  rules:
    - if: '$CI_COMMIT_REF_NAME == "dev" || $CI_COMMIT_REF_NAME == "main"'

# =============================================
# BUILD STAGE
# =============================================

# Build and Push Frontend
build_and_push_frontend:
  <<: *docker_build_template
  stage: build
  script:
    - echo "üèóÔ∏è Building frontend image..."
    - |
      docker build \
        --build-arg BUILD_VERSION=${CI_COMMIT_SHORT_SHA} \
        --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
        -t $FRONTEND_IMAGE:$COMMIT_TAG \
        -t $FRONTEND_IMAGE:latest \
        ./client
    - echo "üìå Pushing frontend image..."
    - docker push $FRONTEND_IMAGE:$COMMIT_TAG
    - docker push $FRONTEND_IMAGE:latest
    - |
      if [ "$CI_COMMIT_REF_NAME" = "main" ]; then
        echo "üìå Tagging production version $VERSION_TAG"
        docker tag $FRONTEND_IMAGE:$COMMIT_TAG $FRONTEND_IMAGE:$VERSION_TAG
        docker push $FRONTEND_IMAGE:$VERSION_TAG
      fi
  rules:
    - if: '$CI_COMMIT_REF_NAME == "dev" || $CI_COMMIT_REF_NAME == "main"'

# Build and Push Backend
build_and_push_backend:
  <<: *docker_build_template
  stage: build
  script:
    - echo "üèóÔ∏è Building backend image..."
    - |
      docker build \
        --build-arg BUILD_VERSION=${CI_COMMIT_SHORT_SHA} \
        --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
        -t $BACKEND_IMAGE:$COMMIT_TAG \
        -t $BACKEND_IMAGE:latest \
        ./backend
    - echo "üìå Pushing backend image..."
    - docker push $BACKEND_IMAGE:$COMMIT_TAG
    - docker push $BACKEND_IMAGE:latest
    - |
      if [ "$CI_COMMIT_REF_NAME" = "main" ]; then
        echo "üìå Tagging production version $VERSION_TAG"
        docker tag $BACKEND_IMAGE:$COMMIT_TAG $BACKEND_IMAGE:$VERSION_TAG
        docker push $BACKEND_IMAGE:$VERSION_TAG
      fi
  rules:
    - if: '$CI_COMMIT_REF_NAME == "dev" || $CI_COMMIT_REF_NAME == "main"'

# Build and Push Database
build_and_push_db:
  <<: *docker_build_template
  stage: build
  before_script:
    - *docker_build_template_before_script
    - apk add --no-cache git
    - git fetch origin dump
    - git show origin/dump:db/employeedb_dump_pg15.sql > db/employeedb_dump_pg15.sql
  script:
    - echo "üèóÔ∏è Building database image..."
    - test -f "db/employeedb_dump_pg15.sql" && echo "‚úÖ SQL file exists" || exit 1
    - |
      docker build \
        --build-arg BUILD_VERSION=${CI_COMMIT_SHORT_SHA} \
        -t $DB_IMAGE:$COMMIT_TAG \
        -t $DB_IMAGE:latest \
        ./db
    - echo "üìå Pushing database image..."
    - docker push $DB_IMAGE:$COMMIT_TAG
    - docker push $DB_IMAGE:latest
    - |
      if [ "$CI_COMMIT_REF_NAME" = "main" ]; then
        echo "üìå Tagging production version $VERSION_TAG"
        docker tag $DB_IMAGE:$COMMIT_TAG $DB_IMAGE:$VERSION_TAG
        docker push $DB_IMAGE:$VERSION_TAG
      fi
  rules:
    - if: '$CI_COMMIT_REF_NAME == "dev" || $CI_COMMIT_REF_NAME == "main"'

# =============================================
# DEPLOY STAGE
# =============================================

# Staging Deployment (Automatic on dev branch)
deploy_staging:
  stage: deploy
  image: alpine:latest
  environment:
    name: staging
    url: https://staging.ems-platform.com
  before_script:
    - apk add --no-cache openssh-client
    - |
      if [ -z "$STAGING_DEPLOY_USER" ] || [ -z "$STAGING_DEPLOY_SERVER" ]; then
        echo "‚ùå Staging deployment variables not set"
        exit 1
      fi
  script:
    - echo "üöÄ Deploying to staging environment..."
    - |
      ssh -o StrictHostKeyChecking=no $STAGING_DEPLOY_USER@$STAGING_DEPLOY_SERVER "
        cd $STAGING_DEPLOY_PATH &&
        echo 'Pulling latest images...' &&
        docker-compose pull &&
        echo 'Starting services...' &&
        docker-compose up -d &&
        echo 'Running health checks...' &&
        sleep 30 &&
        echo '‚úÖ Staging deployment completed successfully'
      "
  rules:
    - if: '$CI_COMMIT_REF_NAME == "dev"'

# Production Deployment (Manual approval required)
deploy_production:
  stage: deploy
  image: alpine:latest
  environment:
    name: production
    url: https://ems-platform.com
  before_script:
    - apk add --no-cache openssh-client curl
    - |
      if [ -z "$DEPLOY_USER" ] || [ -z "$DEPLOY_SERVER" ]; then
        echo "‚ùå Production deployment variables not set"
        exit 1
      fi
  script:
    - echo "üöÄ Deploying to production environment..."
    - |
      ssh -o StrictHostKeyChecking=no $DEPLOY_USER@$DEPLOY_SERVER "
        cd $DEPLOY_PATH &&
        echo 'Stopping existing services...' &&
        docker-compose down &&
        echo 'Pulling latest images...' &&
        docker-compose pull &&
        echo 'Starting services...' &&
        docker-compose up -d &&
        echo 'Cleaning up old images...' &&
        docker system prune -f &&
        echo '‚úÖ Production deployment completed successfully'
      "
    - echo "üè• Running production health check..."
    - |
      # Health check with retries
      for i in 1 2 3 4 5; do
        if curl -f https://ems-platform.com/api/health; then
          echo "‚úÖ Production health check passed"
          break
        else
          echo "‚ö†Ô∏è Health check attempt $i failed, retrying..."
          sleep 30
        fi
      done
  rules:
    - if: '$CI_COMMIT_REF_NAME == "main"'
      when: manual

# =============================================
# POST-CLEANUP STAGE
# =============================================

# Cleanup job to remove temporary resources
cleanup:
  stage: post-cleanup
  image: docker:24
  services:
    - docker:24-dind
  script:
    - echo "üßπ Cleaning up resources..."
    - echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin
    - |
      # Remove local images to save disk space
      docker system prune -f --filter "until=24h"
    - echo "‚úÖ Cleanup completed"
  when: always
  rules:
    - if: '$CI_COMMIT_REF_NAME == "dev" || $CI_COMMIT_REF_NAME == "main"'

# =============================================
# NOTIFICATIONS (Example structure)
# =============================================

# Uncomment and configure based on your notification preferences
#workflow:
#  rules:
#    - if: $CI_COMMIT_BRANCH == "main"
#    - if: $CI_COMMIT_BRANCH == "dev"
#    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
#    - if: $CI_COMMIT_TAG
#
#integrate:
#  webhooks:
#    - url: "https://hooks.slack.com/services/your-webhook"
#      on_success: always
#      on_failure: always