stages:
  - test
  - build
  - push
  - deploy

variables:
  DOCKER_TLS_CERTDIR: "/certs"

  # Images Docker
  FRONTEND_IMAGE: "amineelalami/ems-platform-frontend"
  BACKEND_IMAGE: "amineelalami/ems-platform-backend"
  DB_IMAGE: "amineelalami/ems-platform-db"

  # Tags
  COMMIT_TAG: "sha-${CI_COMMIT_SHORT_SHA}-${CI_PIPELINE_ID}"
  VERSION_TAG: "v${CI_PIPELINE_ID}"

# ----------- Cache -----------
cache:
  key: "${CI_COMMIT_REF_SLUG}"
  paths:
    - client/node_modules/
    - backend/node_modules/
  policy: pull-push

# ----------- Templates -----------

.test_template: &test_template
  image: node:20
  stage: test
  before_script:
    - cd $COMPONENT_DIR
    - npm ci
  script:
    - echo "üîç Running $CI_JOB_NAME..."
    - npm run lint || echo "‚ö†Ô∏è  Lint skipped or failed"
    - npm test || echo "‚ö†Ô∏è  Tests skipped or failed"
  rules:
    - if: '$CI_COMMIT_REF_NAME == "dev" || $CI_COMMIT_REF_NAME == "main"'

.build_template: &build_template
  image: docker:24
  stage: build
  services:
    - name: docker:24-dind
      command: ["--tls=false"]
  variables:
    DOCKER_HOST: "tcp://docker:2376"
    DOCKER_TLS_VERIFY: "0"
  before_script:
    - docker info
  script:
    - echo "üèóÔ∏è Building $IMAGE_NAME:$COMMIT_TAG"
    - docker build -t $IMAGE_NAME:$COMMIT_TAG -t $IMAGE_NAME:latest $BUILD_CONTEXT
  rules:
    - if: '$CI_COMMIT_REF_NAME == "dev" || $CI_COMMIT_REF_NAME == "main"'

.push_template: &push_template
  image: docker:24
  stage: push
  services:
    - name: docker:24-dind
      command: ["--tls=false"]
  variables:
    DOCKER_HOST: "tcp://docker:2376"
    DOCKER_TLS_VERIFY: "0"
  before_script:
    - echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin
  script:
    - echo "üìå Pushing $IMAGE_NAME"
    - docker push $IMAGE_NAME:$COMMIT_TAG
    - docker push $IMAGE_NAME:latest
    - |
      if [ "$CI_COMMIT_REF_NAME" = "main" ]; then
        echo "üìå Tagging production version $VERSION_TAG"
        docker tag $IMAGE_NAME:$COMMIT_TAG $IMAGE_NAME:$VERSION_TAG
        docker push $IMAGE_NAME:$VERSION_TAG
      fi
  rules:
    - if: '$CI_COMMIT_REF_NAME == "dev" || $CI_COMMIT_REF_NAME == "main"'

# ----------- Jobs -----------

test_frontend:
  <<: *test_template
  variables:
    COMPONENT_DIR: "client"
    CI_JOB_NAME: "frontend"

test_backend:
  <<: *test_template
  variables:
    COMPONENT_DIR: "backend"
    CI_JOB_NAME: "backend"

test_db:
  image: docker:24
  stage: test
  services:
    - name: docker:24-dind
      command: ["--tls=false"]
  variables:
    DOCKER_HOST: "tcp://docker:2376"
    DOCKER_TLS_VERIFY: "0"
    POSTGRES_DB: "employeedb"
  before_script:
    - apk add --no-cache postgresql-client bash
    - docker info
  script:
    # V√©rification des variables
    - echo "üîç Testing database image..."
    - echo "POSTGRES_USER: $POSTGRES_USER"
    - echo "POSTGRES_DB: $POSTGRES_DB"

    # Build de l'image
    - echo "üèóÔ∏è Building database image..."
    - docker build -t $DB_IMAGE:test ./db

    # D√©marrage du conteneur
    - echo "üêò Starting test database container..."
    - docker run -d --name test-db -e POSTGRES_USER="$POSTGRES_USER" -e POSTGRES_PASSWORD="$POSTGRES_PASSWORD" -e POSTGRES_DB="$POSTGRES_DB" -p 5432:5432 $DB_IMAGE:test

    # Attente que la base soit pr√™te
    - echo "‚è≥ Waiting for database to be ready..."
    - |
      for i in {1..30}; do
        if pg_isready -h localhost -p 5432 -U $POSTGRES_USER; then
          echo "‚úÖ Database is ready!"
          break
        fi
        echo "‚è±Ô∏è Waiting... attempt $i/30"
        sleep 2
      done

    # Test de connexion
    - echo "‚úÖ Testing database connection..."
    - PGPASSWORD="$POSTGRES_PASSWORD" psql -h localhost -U "$POSTGRES_USER" -d "$POSTGRES_DB" -c "SELECT 'Database connection successful' as status;"

    # V√©rification des tables
    - echo "üìä Checking database structure..."
    - PGPASSWORD="$POSTGRES_PASSWORD" psql -h localhost -U "$POSTGRES_USER" -d "$POSTGRES_DB" -c "\dt" || echo "No tables found or error"

  after_script:
    - echo "üßπ Cleaning up test containers..."
    - docker stop test-db || true
    - docker rm test-db || true
  rules:
    - if: '$CI_COMMIT_REF_NAME == "dev" || $CI_COMMIT_REF_NAME == "main"'

build_frontend:
  <<: *build_template
  variables:
    IMAGE_NAME: $FRONTEND_IMAGE
    BUILD_CONTEXT: "./client"

build_backend:
  <<: *build_template
  variables:
    IMAGE_NAME: $BACKEND_IMAGE
    BUILD_CONTEXT: "./backend"

build_db:
  <<: *build_template
  variables:
    IMAGE_NAME: $DB_IMAGE
    BUILD_CONTEXT: "./db"

push_frontend:
  <<: *push_template
  variables:
    IMAGE_NAME: $FRONTEND_IMAGE
  dependencies:
    - build_frontend

push_backend:
  <<: *push_template
  variables:
    IMAGE_NAME: $BACKEND_IMAGE
  dependencies:
    - build_backend

push_db:
  <<: *push_template
  variables:
    IMAGE_NAME: $DB_IMAGE
  dependencies:
    - build_db

deploy_production:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client
  script:
    - echo "üöÄ Deploying to production server..."
    - |
      ssh -o StrictHostKeyChecking=no $DEPLOY_USER@$DEPLOY_SERVER "
        cd $DEPLOY_PATH &&
        docker-compose pull &&
        docker-compose up -d
      "
  environment:
    name: production
    url: https://your-production-url.com
  rules:
    - if: '$CI_COMMIT_REF_NAME == "main"'
      when: manual